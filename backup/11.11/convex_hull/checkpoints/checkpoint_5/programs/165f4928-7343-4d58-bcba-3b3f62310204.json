{"id": "165f4928-7343-4d58-bcba-3b3f62310204", "code": "# Copyright (c) 2025 Ori Press and the AlgoTune contributors\n# https://github.com/oripress/AlgoTune\nimport logging\nimport random\nfrom typing import Any\n\nimport numpy as np\nfrom scipy.spatial import ConvexHull\n\nfrom AlgoTuneTasks.base import register_task, Task\n\n\n@register_task(\"convex_hull\")\nclass ConvexHullTask(Task):\n    def __init__(self, **kwargs):\n        \"\"\"\n        Initialize the Convex Hull task.\n\n        In this task, you are given a set of points in 2D space, and your goal is to compute the convex hull,\n        which is the smallest convex polygon that contains all the points.\n        \"\"\"\n        super().__init__(**kwargs)\n\n    def generate_problem(self, n: int, random_seed: int = 42) -> dict[str, Any]:\n        \"\"\"\n        Generate a random Convex Hull problem.\n\n        The complexity and characteristics (distribution, shape, noise, etc.) are determined\n        based on the complexity parameter 'n' and the random seed.\n\n        :param n: Number of points to generate (influences complexity).\n        :param random_seed: Seed for reproducibility.\n        :return: A dictionary representing the Convex Hull problem.\n        \"\"\"\n        # Determine parameters based on n and random_seed\n        random.seed(random_seed)\n        np.random.seed(random_seed)\n\n        # Determine distribution type based on n\n        available_distributions = [\n            \"uniform\",\n            \"normal\",\n            \"grid\",\n            \"circle\",\n            \"clusters\",\n            \"known_simple\",\n            \"known_complex\",\n        ]\n        if n < 10:\n            weights = [0.2, 0.1, 0.1, 0.1, 0.1, 0.2, 0.2]  # Favor simple/known for low n\n        elif n < 50:\n            weights = [0.25, 0.15, 0.15, 0.1, 0.15, 0.1, 0.1]\n        else:\n            weights = [0.3, 0.2, 0.15, 0.15, 0.1, 0.05, 0.05]  # Favor uniform/normal for high n\n        distribution_type = random.choices(available_distributions, weights=weights, k=1)[0]\n\n        # Ensure n is appropriate for known types\n        if distribution_type == \"known_simple\" and n < 4:\n            n = 4\n        if distribution_type == \"known_complex\" and n < 10:\n            n = 10\n\n        # Determine other parameters based on n and distribution_type\n        boundary_points = random.random() < (\n            0.3 + min(0.5, n / 100.0)\n        )  # Higher chance with more points\n        shape = (\n            random.choice([\"square\", \"circle\", \"triangle\", \"cross\"])\n            if distribution_type == \"uniform\"\n            else \"square\"\n        )\n        noise_level = random.uniform(\n            0, 0.05 + min(0.3, n / 200.0)\n        )  # Noise increases slightly with n\n        outliers = random.randint(0, max(0, n // 10))  # More outliers possible with more points\n        cluster_count = random.randint(2, max(3, n // 8)) if distribution_type == \"clusters\" else 1\n\n        logging.debug(\n            f\"Generating Convex Hull problem with n={n} points, derived distribution={distribution_type}, \"\n            f\"shape={shape}, noise={noise_level:.2f}, outliers={outliers}, clusters={cluster_count}, seed={random_seed}\"\n        )\n\n        # --- The rest of the generation logic uses the derived parameters ---\n        points = []\n\n        # Generate points based on the distribution type\n        if distribution_type == \"uniform\":\n            if shape == \"square\":\n                points = np.random.rand(n, 2)  # Points in [0, 1] x [0, 1]\n            elif shape == \"circle\":\n                r = np.sqrt(np.random.rand(n))  # Sqrt for uniform distribution in a circle\n                theta = np.random.rand(n) * 2 * np.pi\n                points = np.vstack([r * np.cos(theta), r * np.sin(theta)]).T\n                points = (points + 1) / 2  # Scale and shift to [0, 1] x [0, 1]\n            elif shape == \"triangle\":\n                # Generate points in a unit triangle using barycentric coordinates\n                u = np.random.rand(n)\n                v = np.random.rand(n)\n                mask = u + v > 1  # If u + v > 1, reflect the point\n                u[mask] = 1 - u[mask]\n                v[mask] = 1 - v[mask]\n                points = np.vstack([u, v]).T  # Triangle vertices at (0,0), (1,0), (0,1)\n            elif shape == \"cross\":\n                # Generate points in a cross shape\n                x = np.random.rand(n)\n                y = np.random.rand(n)\n                if random.random() < 0.5:\n                    x = 0.5 + (x - 0.5) * 0.2  # Concentrate around x=0.5\n                else:\n                    y = 0.5 + (y - 0.5) * 0.2  # Concentrate around y=0.5\n                points = np.vstack([x, y]).T\n\n        elif distribution_type == \"normal\":\n            # Generate points with normal distribution around center\n            points = np.random.randn(n, 2) * 0.15 + 0.5\n            points = np.clip(points, 0, 1)  # Clip points to stay within [0, 1] x [0, 1]\n\n        elif distribution_type == \"grid\":\n            # Determine grid size based on n\n            grid_size = int(np.ceil(np.sqrt(n)))\n            x = np.linspace(0, 1, grid_size)\n            y = np.linspace(0, 1, grid_size)\n            xx, yy = np.meshgrid(x, y)\n            grid_points = np.vstack([xx.flatten(), yy.flatten()]).T\n            points = grid_points[:n]  # Take the first n points\n            # Add some noise to the grid\n            points += np.random.randn(*points.shape) * noise_level * 0.1\n            points = np.clip(points, 0, 1)  # Clip points to stay within [0, 1] x [0, 1]\n\n        elif distribution_type == \"circle\":\n            # Generate points on a circle\n            theta = np.linspace(0, 2 * np.pi, n, endpoint=False)\n            radius = 0.4\n            x = 0.5 + radius * np.cos(theta)\n            y = 0.5 + radius * np.sin(theta)\n            points = np.vstack([x, y]).T\n            # Add some noise\n            points += np.random.randn(*points.shape) * noise_level * radius\n            points = np.clip(points, 0, 1)  # Clip points to stay within [0, 1] x [0, 1]\n\n        elif distribution_type == \"clusters\":\n            # Generate cluster centers\n            centers = np.random.rand(cluster_count, 2)\n            # Assign points to clusters\n            points_per_cluster = n // cluster_count\n            points = []\n            for i in range(cluster_count):\n                cluster_points = np.random.randn(points_per_cluster, 2) * 0.1 + centers[i]\n                points.append(cluster_points)\n            # Add remaining points to a random cluster\n            remaining = n - points_per_cluster * cluster_count\n            if remaining > 0:\n                extra_points = np.random.randn(remaining, 2) * 0.1 + centers[0]\n                points.append(extra_points)\n            points = np.vstack(points)\n            points = np.clip(points, 0, 1)  # Clip points to stay within [0, 1] x [0, 1]\n\n        # Create known simple examples\n        elif distribution_type == \"known_simple\":\n            if n >= 4:  # Square\n                # Ensure dtype is float to prevent casting errors when adding noise\n                points = np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]], dtype=float)\n                # Fill in with random points if needed\n                if n > 4:\n                    extra_points = np.random.rand(n - 4, 2) * 0.8 + 0.1  # Inside the square\n                    points = np.vstack([points, extra_points])\n            # Note: The logic in generate_problem ensures n >= 4 for this type now.\n\n        # Create known complex examples\n        elif distribution_type == \"known_complex\":\n            if n >= 10:  # Star-like shape\n                angles = np.linspace(0, 2 * np.pi, 10, endpoint=False)\n                outer_radius = 0.45\n                inner_radius = 0.2\n                x = []\n                y = []\n                for i, angle in enumerate(angles):\n                    r = outer_radius if i % 2 == 0 else inner_radius\n                    x.append(0.5 + r * np.cos(angle))\n                    y.append(0.5 + r * np.sin(angle))\n                star_points = np.vstack([x, y]).T\n                # Fill with random interior points if needed\n                if n > 10:\n                    extra_points = []\n                    while len(extra_points) < n - 10:\n                        point = np.random.rand(2) * 0.8 + 0.1  # Point in [0.1, 0.9] x [0.1, 0.9]\n                        # Simple check if it's inside the main circle\n                        if (point[0] - 0.5) ** 2 + (point[1] - 0.5) ** 2 < (\n                            inner_radius * 1.2\n                        ) ** 2:\n                            extra_points.append(point)\n                    extra_points = np.array(extra_points)\n                    points = np.vstack([star_points, extra_points[: n - 10]])\n                else:\n                    points = star_points[:n]\n\n        # Add boundary points if requested\n        if (\n            boundary_points\n            and n >= 8\n            and distribution_type not in [\"known_simple\", \"known_complex\"]\n        ):\n            # Corner points\n            corners = np.array([[0, 0], [1, 0], [1, 1], [0, 1]])\n            # Replace some points with corners\n            indices = np.random.choice(len(points), size=min(4, len(points)), replace=False)\n            points[indices] = corners\n\n            # Add some edge midpoints if we have enough points\n            if n >= 12:\n                edges = np.array([[0.5, 0], [1, 0.5], [0.5, 1], [0, 0.5]])\n                indices = np.random.choice(len(points), size=min(4, len(points)), replace=False)\n                # Make sure we don't overwrite the corners\n                for i in range(min(4, len(indices))):\n                    if indices[i] not in indices[: min(4, len(points))]:\n                        points[indices[i]] = edges[i]\n\n        # Add noise to all points if requested\n        if noise_level > 0 and distribution_type not in [\n            \"grid\",\n            \"circle\",\n        ]:  # Already added noise for these\n            points += np.random.randn(*points.shape) * noise_level * 0.1\n            points = np.clip(points, 0, 1)  # Clip points to stay within [0, 1] x [0, 1]\n\n        # Add outliers if requested\n        if outliers > 0:\n            # Create outliers by placing points far outside the main distribution\n            outlier_points = np.random.rand(outliers, 2) * 3 - 1  # Points in [-1, 2] x [-1, 2]\n            # Replace some points with outliers\n            if len(points) > outliers:\n                indices = np.random.choice(len(points), size=outliers, replace=False)\n                points[indices] = outlier_points\n            else:\n                # If we don't have enough points, just add the outliers\n                points = np.vstack([points, outlier_points[: len(points)]])\n\n        # Ensure points are unique\n        points = np.unique(points, axis=0)\n\n        # If we lost some points due to uniqueness, regenerate them\n        while len(points) < n:\n            new_points = np.random.rand(n - len(points), 2)\n            points = np.vstack([points, new_points])\n            points = np.unique(points, axis=0)\n\n        # Ensure we have exactly n points\n        # If n was less than 3 initially, this could result in < 3 points\n        # points = points[:n]\n\n        # --- Ensure at least 3 points for Convex Hull ---\n        min_required = 3\n        if len(points) < min_required:\n            logging.warning(\n                f\"Generated fewer than {min_required} unique points ({len(points)}). Adding random points to meet minimum.\"\n            )\n            while len(points) < min_required:\n                # Add random points, ensuring they are likely unique from existing ones\n                new_point = np.random.rand(1, 2)\n                # Quick check for exact duplication (unlikely with float, but safe)\n                if not np.any(np.all(points == new_point, axis=1)):\n                    points = np.vstack([points, new_point])\n\n        # Now ensure we have exactly n points if n >= 3, otherwise we have 3\n        if n >= min_required:\n            points = points[:n]  # Trim if we added extra to meet min_required but n was larger\n        # else: points array already has 3 points\n\n        problem = {\n            \"points\": points,\n        }\n\n        logging.debug(f\"Generated Convex Hull problem with {len(points)} points.\")\n        return problem\n\n    def solve(self, problem: dict[str, Any]) -> dict[str, Any]:\n        \"\"\"\n        Solve the Convex Hull problem using scipy.spatial.ConvexHull.\n\n        :param problem: A dictionary representing the Convex Hull problem.\n        :return: A dictionary with keys:\n                 \"hull_vertices\": List of indices of the points that form the convex hull.\n                 \"hull_points\": List of coordinates of the points that form the convex hull.\n        \"\"\"\n        points = problem[\"points\"]\n        hull = ConvexHull(points)\n\n        # Get the vertices of the convex hull\n        hull_vertices = hull.vertices.tolist()\n\n        # Get the points that form the hull in order\n        hull_points = points[hull.vertices].tolist()\n\n        solution = {\"hull_vertices\": hull_vertices, \"hull_points\": hull_points}\n\n        return solution\n\n    def is_solution(self, problem: dict[str, Any], solution: dict[str, Any]) -> bool:\n        \"\"\"\n        Validate the Convex Hull solution.\n\n        This method checks:\n          - The solution contains the keys 'hull_vertices' and 'hull_points'.\n          - The hull_vertices are valid indices into the original points array.\n          - The hull_points correspond to the correct points from the original array.\n          - The resulting polygon is convex.\n          - The hull contains all original points (either inside or on the boundary).\n\n        :param problem: A dictionary representing the Convex Hull problem with key \"points\".\n        :param solution: A dictionary containing the solution with keys \"hull_vertices\" and \"hull_points\".\n        :return: True if solution is valid, else False.\n        \"\"\"\n        points = problem.get(\"points\")\n        if points is None:\n            logging.error(\"Problem does not contain 'points'.\")\n            return False\n\n        # Check that the solution contains the required keys.\n        for key in [\"hull_vertices\", \"hull_points\"]:\n            if key not in solution:\n                logging.error(f\"Solution does not contain '{key}' key.\")\n                return False\n\n        try:\n            hull_vertices = np.array(solution[\"hull_vertices\"], dtype=int)\n            hull_points = np.array(solution[\"hull_points\"])\n        except Exception as e:\n            logging.error(f\"Error converting solution lists to numpy arrays: {e}\")\n            return False\n\n        # Check that hull_vertices are valid indices\n        if np.any(hull_vertices < 0) or np.any(hull_vertices >= len(points)):\n            logging.error(\"Hull vertices contain invalid indices.\")\n            return False\n\n        # Check that hull_points correspond to the correct points\n        if not np.allclose(points[hull_vertices], hull_points, atol=1e-6):\n            logging.error(\n                \"Hull points do not correspond to the correct indices in the original points array.\"\n            )\n            return False\n\n        # Check that we have at least 3 points for a valid hull in 2D\n        if len(hull_vertices) < 3:\n            logging.error(\"Convex hull must have at least 3 vertices in 2D.\")\n            return False\n\n        # Check convexity by ensuring all internal angles are less than 180 degrees\n        n = len(hull_vertices)\n        for i in range(n):\n            prev_point = hull_points[i - 1]\n            curr_point = hull_points[i]\n            next_point = hull_points[(i + 1) % n]\n\n            # Calculate vectors\n            v1 = np.array([curr_point[0] - prev_point[0], curr_point[1] - prev_point[1]])\n            v2 = np.array([next_point[0] - curr_point[0], next_point[1] - curr_point[1]])\n\n            # Cross product should be positive for counter-clockwise ordering\n            cross_product = v1[0] * v2[1] - v1[1] * v2[0]\n            if cross_product < 0:\n                logging.error(\"Hull is not convex or not ordered counter-clockwise.\")\n                return False\n\n        # Check that all points are contained within or on the boundary of the hull\n        for point in points:\n            if self._point_outside_hull(point, hull_points):\n                logging.error(\"Not all points are contained within the convex hull.\")\n                return False\n\n        return True\n\n    def _point_outside_hull(self, point: np.ndarray, hull_points: np.ndarray) -> bool:\n        \"\"\"\n        Check if a point is outside the convex hull.\n\n        :param point: A point (x, y).\n        :param hull_points: List of (x, y) coordinates of the hull vertices in counter-clockwise order.\n        :return: True if the point is outside the hull, False otherwise.\n        \"\"\"\n        n = len(hull_points)\n        for i in range(n):\n            p1 = hull_points[i]\n            p2 = hull_points[(i + 1) % n]\n\n            # Check if the point is to the right of the edge (p1, p2)\n            cross_product = (p2[0] - p1[0]) * (point[1] - p1[1]) - (p2[1] - p1[1]) * (\n                point[0] - p1[0]\n            )\n\n            # If cross product is negative, the point is to the right of the edge (outside the hull)\n            if cross_product < -1e-9:  # Using a small epsilon for numerical stability\n                return True\n\n        return False\n", "language": "python", "parent_id": null, "generation": 0, "timestamp": 1762867085.0479379, "iteration_found": 0, "metrics": {"combined_score": 0.0, "mean_speedup": 0.0, "num_valid": 0.0, "success_rate": 0.0, "accuracy": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"island": 0}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}