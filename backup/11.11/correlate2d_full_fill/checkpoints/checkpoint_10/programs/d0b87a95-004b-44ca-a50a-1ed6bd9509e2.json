{"id": "d0b87a95-004b-44ca-a50a-1ed6bd9509e2", "code": "# Copyright (c) 2025 Ori Press and the AlgoTune contributors\n# https://github.com/oripress/AlgoTune\nimport logging\n\nimport numpy as np\nfrom scipy import signal\n\nfrom AlgoTuneTasks.base import register_task, Task\n\n\n@register_task(\"correlate2d_full_fill\")\nclass Correlate2DFullFill(Task):\n    def __init__(self, **kwargs):\n        \"\"\"\n        Initialize the Correlate2DFullFill Task.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.mode = \"full\"\n        self.boundary = \"fill\"\n\n    def generate_problem(self, n: int = 1, random_seed: int = 1234) -> tuple:\n        \"\"\"\n        Generate a 2D correlation problem.\n\n        The problem consists of a pair of 2D arrays:\n          - The first array has shape (30*n, 30*n).\n          - The second array has shape (8*n, 8*n).\n        These arrays are generated using a random number generator with the specified seed.\n        As n increases, the arrays become larger, increasing the computational complexity of the correlation.\n\n        :param n: Scaling factor for the array dimensions.\n        :param random_seed: Seed for reproducibility.\n        :return: A tuple (a, b) of 2D arrays.\n        \"\"\"\n        rng = np.random.default_rng(random_seed)\n        a = rng.standard_normal((30 * n, 30 * n))\n        b = rng.standard_normal((8 * n, 8 * n))\n        return (a, b)\n\n    def solve(self, problem: tuple) -> np.ndarray:\n        \"\"\"\n        Compute the 2D correlation of arrays a and b using \"full\" mode and \"fill\" boundary.\n\n        :param problem: A tuple (a, b) of 2D arrays.\n        :return: A 2D array containing the correlation result.\n        \"\"\"\n        a, b = problem\n        result = signal.correlate2d(a, b, mode=self.mode, boundary=self.boundary)\n        return result\n\n    def is_solution(self, problem: tuple, solution: np.ndarray) -> bool:\n        \"\"\"\n        Check if the 2D correlation solution is valid and optimal.\n\n        A valid solution must match the reference implementation (signal.correlate2d)\n        with \"full\" mode and \"fill\" boundary, within a small tolerance.\n\n        :param problem: A tuple (a, b) of 2D arrays.\n        :param solution: The computed correlation result.\n        :return: True if the solution is valid and optimal, False otherwise.\n        \"\"\"\n        a, b = problem\n        reference = signal.correlate2d(a, b, mode=self.mode, boundary=self.boundary)\n        tol = 1e-6\n        error = np.linalg.norm(solution - reference) / (np.linalg.norm(reference) + 1e-12)\n        if error > tol:\n            logging.error(f\"Correlate2D solution error {error} exceeds tolerance {tol}.\")\n            return False\n        return True\n", "language": "python", "parent_id": null, "generation": 0, "timestamp": 1762867083.9344661, "iteration_found": 0, "metrics": {"combined_score": 0.0, "mean_speedup": 0.0, "num_valid": 0.0, "success_rate": 0.0, "accuracy": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"island": 0}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}