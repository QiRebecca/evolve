{"id": "e5596813-086d-41d8-9ce4-183b24e0effb", "code": "# Copyright (c) 2025 Ori Press and the AlgoTune contributors\n# https://github.com/oripress/AlgoTune\nimport base64\nimport hmac\nimport logging\n\n# Removed math, string imports\nfrom typing import Any, Union  # Standard library\n\nimport numpy as np  # Third-party needed for seeded random bytes\n\nfrom AlgoTuneTasks.base import register_task, Task  # Local application\n\n\n@register_task(\"base64_encoding\")\nclass Base64Encoding(Task):\n    \"\"\"\n    Base64Encoding Task:\n\n    Encode binary data (generated using a Zipfian distribution of words)\n    using the standard Base64 algorithm.\n    Encode binary data using the standard Base64 algorithm.\n    The difficulty scales with the size of the input data.\n    \"\"\"\n\n    # Constants for data generation\n    DEFAULT_PLAINTEXT_MULTIPLIER = 2048  # Target bytes of plaintext per unit of n\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n    def generate_problem(self, n: int, random_seed: int = 1) -> dict[str, Any]:\n        \"\"\"\n        Generate random binary data for the Base64 encoding task.\n\n        Args:\n            n (int): Scaling parameter, determines the target plaintext size.\n            random_seed (int): Seed for reproducibility.\n\n        Returns:\n            dict: A dictionary containing the problem parameters (plaintext).\n        \"\"\"\n        # Use n to scale the target plaintext size\n        target_plaintext_size = max(0, n * self.DEFAULT_PLAINTEXT_MULTIPLIER)\n\n        logging.debug(\n            f\"Generating Base64 encoding problem (random bytes) with n={n} \"\n            f\"(target_plaintext_size={target_plaintext_size}), random_seed={random_seed}\"\n        )\n\n        if target_plaintext_size == 0:\n            logging.debug(\"Target size is 0, returning empty bytes.\")\n            return {\"plaintext\": b\"\"}\n\n        # Seed the numpy random number generator for reproducibility\n        rng = np.random.default_rng(random_seed)\n\n        # Generate random bytes using the seeded generator\n        plaintext_bytes = rng.bytes(target_plaintext_size)\n\n        logging.debug(f\"Generated final plaintext size: {len(plaintext_bytes)} bytes\")\n        return {\"plaintext\": plaintext_bytes}\n\n    def solve(self, problem: dict[str, Any]) -> dict[str, bytes]:\n        \"\"\"\n        Encode the plaintext using the Base64 algorithm.\n\n        Args:\n            problem (dict): The problem dictionary generated by `generate_problem`.\n\n        Returns:\n            dict: A dictionary containing 'encoded_data'.\n        \"\"\"\n        plaintext = problem[\"plaintext\"]\n\n        try:\n            # Encode the data using standard Base64\n            encoded_data = base64.b64encode(plaintext)\n            return {\"encoded_data\": encoded_data}\n\n        except Exception as e:\n            logging.error(f\"Error during Base64 encoding in solve: {e}\")\n            raise  # Re-raise exception\n\n    def is_solution(self, problem: dict[str, Any], solution: Union[dict[str, bytes], Any]) -> bool:\n        \"\"\"\n        Verify the provided solution by comparing its encoded data\n        against the result obtained from calling the task's own solve() method.\n\n        Args:\n            problem (dict): The problem dictionary.\n            solution (dict): The proposed solution dictionary with 'encoded_data'.\n\n        Returns:\n            bool: True if the solution matches the result from self.solve().\n        \"\"\"\n        if not isinstance(solution, dict) or \"encoded_data\" not in solution:\n            logging.error(\n                f\"Invalid solution format. Expected dict with 'encoded_data'. Got: {type(solution)}\"\n            )\n            return False\n\n        try:\n            # Get the correct result by calling the solve method\n            reference_result = self.solve(problem)\n            reference_encoded_data = reference_result[\"encoded_data\"]\n        except Exception as e:\n            # If solve itself fails, we cannot verify the solution\n            logging.error(f\"Failed to generate reference solution in is_solution: {e}\")\n            return False\n\n        solution_encoded_data = solution[\"encoded_data\"]\n\n        # Ensure type is bytes before comparison\n        if not isinstance(solution_encoded_data, bytes):\n            logging.error(\"Solution 'encoded_data' is not bytes.\")\n            return False\n\n        # Direct comparison is sufficient for Base64 output.\n        # Using hmac.compare_digest for consistency and potential timing attack resistance.\n        encoded_data_match = hmac.compare_digest(reference_encoded_data, solution_encoded_data)\n\n        return encoded_data_match\n", "language": "python", "parent_id": null, "generation": 0, "timestamp": 1762867186.878892, "iteration_found": 0, "metrics": {"combined_score": 0.0, "mean_speedup": 0.0, "num_valid": 0.0, "success_rate": 0.0, "accuracy": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"island": 0}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}