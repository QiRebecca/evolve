{"id": "dfebfc74-05ec-4b32-92d2-217681087475", "code": "# Copyright (c) 2025 Ori Press and the AlgoTune contributors\n# https://github.com/oripress/AlgoTune\nimport logging\nfrom itertools import product\n\nimport numpy as np\nfrom scipy import signal\n\nfrom AlgoTuneTasks.base import register_task, Task\n\n\n@register_task(\"correlate_1d\")\nclass Correlate1D(Task):\n    def __init__(self, **kwargs):\n        \"\"\"\n        Initialize the Correlate1D Task.\n        :param kwargs: Additional keyword arguments.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.mode = \"full\"\n\n    def generate_problem(self, n: int = 1, random_seed: int = 1234) -> list:\n        \"\"\"\n        Generate a list of 1D array pairs for correlation.\n\n        For each pair of lengths (ma, nb) chosen from\n        (1, 2, 8, 13, 30, 36, 50, 75), two 1D arrays are generated using a standard normal distribution.\n        The sizes of the arrays scale with the parameter n.\n\n        :param n: Scaling factor for the array lengths.\n        :param random_seed: Seed for reproducibility.\n        :return: A list of tuples, each containing two 1D arrays.\n        \"\"\"\n        rng = np.random.default_rng(random_seed)\n        pairs = []\n        for ma, nb in product((1, 2, 8, 13, 30, 36, 50, 75), repeat=2):\n            a = rng.standard_normal(ma * n)\n            b = rng.standard_normal(nb * n)\n            pairs.append((a, b))\n        return pairs\n\n    def solve(self, problem: list) -> list:\n        \"\"\"\n        Compute the 1D correlation for each valid pair in the problem list.\n\n        For mode 'valid', process only pairs where the length of the second array does not exceed the first.\n        Return a list of 1D arrays representing the correlation results.\n\n        :param problem: A list of tuples of 1D arrays.\n        :return: A list of 1D correlation results.\n        \"\"\"\n        results = []\n        for a, b in problem:\n            if self.mode == \"valid\" and b.shape[0] > a.shape[0]:\n                continue\n            res = signal.correlate(a, b, mode=self.mode)\n            results.append(res)\n        return results\n\n    def is_solution(self, problem: list, solution: list) -> bool:\n        \"\"\"\n        Check if the 1D correlation solution is valid and optimal.\n\n        A valid solution must:\n        1. Have the correct number of results (one for each valid pair)\n        2. Match the reference results within a small tolerance\n\n        :param problem: A list of tuples of 1D arrays.\n        :param solution: A list of 1D correlation results.\n        :return: True if the solution is valid and optimal, False otherwise.\n        \"\"\"\n        tol = 1e-6\n        total_diff = 0.0\n        total_ref = 0.0\n        valid_pairs = []\n        for a, b in problem:\n            valid_pairs.append((a, b))\n        if len(valid_pairs) != len(solution):\n            logging.error(\"Number of valid pairs does not match number of solution results.\")\n            return False\n        for i, (a, b) in enumerate(valid_pairs):\n            ref = signal.correlate(a, b, mode=self.mode)\n            total_diff += np.linalg.norm(solution[i] - ref)\n            total_ref += np.linalg.norm(ref)\n        rel_error = total_diff / (total_ref + 1e-12)\n        if rel_error > tol:\n            logging.error(\n                f\"Correlate1D aggregated relative error {rel_error} exceeds tolerance {tol}.\"\n            )\n            return False\n        return True\n", "language": "python", "parent_id": null, "generation": 0, "timestamp": 1762867117.4931822, "iteration_found": 0, "metrics": {"combined_score": 0.0, "mean_speedup": 0.0, "num_valid": 0.0, "success_rate": 0.0, "accuracy": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"island": 0}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}