from typing import Any
import numpy as np
import logging
import sklearn
from sklearn.decomposition import NMF

class Solver:
    def solve(self, problem, **kwargs) -> Any:
        """
        Solve Non-Negative Matrix Factorization using sklearn's NMF.
        The implementation follows the baseline but only uses the core logic.
        """
        try:
            n_components = problem.get("n_components")
            X = np.array(problem["X"], dtype=float)
            model = NMF(n_components=n_components, init="random", random_state=0)
            W = model.fit_transform(X)
            H = model.components_
            return {"W": W.tolist(), **{"H": H.tolist()}}
        end:???,??????????????????????????????..??..???..?..????..



We have a problem: The assistant output is wrong. It includes stray text after return. We need to produce correct solver.py. We need to implement solve method that returns W and H. We can use sklearn NMF. But we need to ensure that the output keys are "W" and "H" as baseline. The validator expects solution keys "W" and "H". The baseline uses "W" and "H". The validator uses solution["W"] and solution["H"]. So we must output keys "W" and "H". The solver's solve method returns dict with keys "W" and "H". The code must be correct.

Also we need to import necessary modules. Use numpy, sklearn. The code must be minimal.

We need to ensure that the solver returns W and H as lists of lists. Use .tolist().

Also we need to handle errors: if any exception, return zero matrices of appropriate shape. But we can just let exception propagate? The validator will call solve again to compute error. If solve fails, it will raise exception and maybe fail. So better to catch exceptions and return zeros.

We need to compute shape: X shape m x n. n_components given. So W shape m x n_components, H shape n_components x n.

Return zeros if error.

Also we need to import logging.

Let's produce final code.

We need to ensure no stray text. Provide only code between sentinels.

Let's write:

from typing import Any
import numpy as np
import logging
from sklearn.decomposition import NMF

class Solver:
    def solve(self, problem, **kwargs) -> Any:
        try:
            X = np.array(problem["X"], dtype=float)
            n_components = problem["n_components"]
            model = NMF(n_components=n_components, init="random", random_state=0, max_iter=200)
            W = model.fit_transform(X)
            H = model.components_
            return {"W": W.tolist(), "H": H.tolist()}
        except Exception as e:
            logging.error(f"Error in NMF solve: {e}")
            X = np.array(problem["X"], dtype=float)
            m, n = X.shape
            n_components = problem["n_components"]
            W = np.zeros((m, n_components), dtype=float).tolist()
            H = np.zeros((n_components, n), dtype=float).tolist()
            return {"W": W, "H": H}

We need to ensure that we import sklearn. But we imported NMF directly. That should be fine.

We need to ensure that we don't use any other packages.

Let's produce final code.assistantfinal<<<SOLVER_PY_START>>>
from typing import Any
import numpy as np
import logging
from sklearn.decomposition import NMF

class Solver:
    def solve(self, problem, **kwargs) -> Any:
        """
        Solve Non-Negative Matrix Factorization using sklearn's NMF.
        Returns a dictionary with keys 'W' and 'H' containing the factor matrices.
        """
        try:
            X = np.array(problem["X"], dtype=float)
            n_components = problem["n_components"]
            model = NMF(n_components=n_components, init="random", random_state=0, max_iter=200)
            W = model.fit_transform(X)
            H = model.components_
            return {"W": W.tolist(), "H": H.tolist()}
        except Exception as e:
            logging.error(f"Error in NMF solve: {e}")
            X = np.array(problem["X"], dtype=float)
            m, n = X.shape
            n_components = problem["n_components"]
            W = np.zeros((m, n_components), dtype=float).tolist()
            H = np.zeros((n_components, n), dtype=float).tolist()
            return {"W": W, "H": H}
<<<SOLVER_PY_END>>>