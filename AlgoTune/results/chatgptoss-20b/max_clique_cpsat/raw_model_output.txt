analysisWe need to produce solver.py that implements a fast maximum clique solver. Baseline uses CP-SAT. We can use networkx's algorithm? But we need to produce same output: list of node indices of maximum clique. We can use a simple branch and bound algorithm with bitsets. For up to maybe 100 nodes? Not specified. We need to be fast. Use Bron–Kerbosch with pivot and degeneracy ordering. That is efficient for moderate graphs. We'll implement a function that returns maximum clique. Use bitset representation via Python integers for speed. For n <= 64, we can use 64-bit ints. But n could be larger. Use Python's int as arbitrary bitset. We'll convert adjacency matrix to adjacency bitsets.

Implement Bron–Kerbosch with pivot and pruning: maintain current clique size, best clique. Use recursion. Use bitset operations: intersection, difference. Use pivot to reduce branching.

We need to return list of indices. We'll maintain best_clique as list.

Implementation details:

- Build adjacency list as list of ints: adj[i] bitmask of neighbors.

- Use recursion function bronk(R, P, X):

    if not P and not X: update best.

    if len(R) + len(P) <= len(best): prune.

    choose pivot u from P|X maximizing |P & adj[u]|.

    for each v in P & ~adj[u]:

        bronk(R|{v}, P & adj[v], X & adj[v])

        P -= {v}

        X += {v}

We need to convert bitset to list of indices quickly. Use bit_length and bit operations.

We need to maintain best_clique as list of indices.

We need to compute len(R) quickly: we can maintain size variable.

We can use recursion with bitset and size.

Implementation:

def bronk(R_mask, P_mask, X_mask, size_R):

    if P_mask == 0 and X_mask == 0:

        if size_R > len(best_clique):

            best_clique = [i for i in range(n) if (R_mask>>i)&1]

    elif size_R + popcount(P_mask) <= len(best_clique):

        return

    else:

        # choose pivot u from P|X maximizing popcount(P & adj[u])

        union = P_mask | X_mask

        # find pivot u: iterate bits of union

        max_deg = -1

        pivot = None

        temp = union

        while temp:

            u = (temp & -temp).bit_length() - 1

            temp &= temp - 1

            deg = popcount(P_mask & adj[u])

            if deg > max_deg:

                max_deg = deg

                pivot = u

        # candidates = P & ~adj[pivot]

        candidates = P_mask & ~adj[pivot]

        temp = candidates

        while temp:

            v = (temp & -temp).bit_length() - 1

            temp &= temp - 1

            bronk(R_mask | (1<<v), P_mask & adj[v], X_mask & adj[v], size_R+1)

            P_mask &= ~(1<<v)

            X_mask |= (1<<v)

We need popcount: use bit_count() in Python 3.8+? Actually int.bit_count() available in 3.8? It's 3.8? It's 3.8? Actually bit_count introduced in 3.8? I think 3.8? Wait: int.bit_count() introduced in Python 3.8? Actually 3.8? I think 3.8? Let's use bin(x).count('1') for compatibility. But we can use x.bit_count() if available. We'll use x.bit_count().

We need to store best_clique as list. Use nonlocal variable.

Edge case: graph may have isolated nodes. The algorithm will handle.

Complexity: good.

We need to import typing.Any.

Return best_clique sorted? Not required but baseline returns list in order of indices. Our algorithm will produce list sorted ascending because we iterate bits in increasing order? In recursion, we may produce unsorted. But we can sort before returning.

Let's implement.

Also we need to handle n=0.

Implementation details: convert adjacency matrix to adjacency bitset: for i in range(n): mask=0; for j in range(n): if problem[i][j]==1: mask|=1<<j. But adjacency matrix includes self? Usually 0. But we can ignore.

We need to ensure graph is symmetric but we trust.

Return list of indices.

Let's produce solver.py content.

We need to include from typing import Any.

Define class Solver with solve method.

We can ignore **kwargs.

Let's write code.

Potential performance: recursion depth up to n. Use sys.setrecursionlimit maybe.

Let's produce final code.

assistantfinal<<<SOLVER_PY_START>>>
from typing import Any

class Solver:
    def solve(self, problem, **kwargs) -> Any:
        """
        Solves the maximum clique problem using a Bron–Kerbosch algorithm with pivoting.
        Returns a list of node indices that form a maximum clique.
        """
        n = len(problem)
        if n == 0:
            return []

        # Build adjacency bitsets
        adj = [0] * n
        for i in range(n):
            mask = 0
            row = problem[i]
            for j, val in enumerate(row):
                if val:
                    mask |= 1 << j
            adj[i] = mask

        best_clique = []

        def popcount(x: int) -> int:
            return x.bit_count()

        def bronk(R_mask: int, P_mask: int, X_mask: int, size_R: int):
            nonlocal best_clique
            if P_mask == 0 and X_mask == 0:
                if size_R > len(best_clique):
                    # Extract indices from R_mask
                    clique = []
                    temp = R_mask
                    while temp:
                        v = (temp & -temp).bit_length() - 1
                        clique.append(v)
                        temp &= temp - 1
                    best_clique = clique
                return
            # Prune if cannot beat current best
            if size_R + popcount(P_mask) <= len(best_clique):
                return

            # Choose pivot u from P ∪ X maximizing |P ∩ N(u)|
            union = P_mask | X_mask
            pivot = None
            max_deg = -1
            temp = union
            while temp:
                u = (temp & -temp).bit_length() - 1
                temp &= temp - 1
                deg = popcount(P_mask & adj[u])
                if deg > max_deg:
                    max_deg = deg
                    pivot = u

            # Candidates: vertices in P not adjacent to pivot
            candidates = P_mask & ~adj[pivot] if pivot is not None else P_mask
            temp = candidates
            while temp:
                v = (temp & -temp).bit_length() - 1
                temp &= temp - 1
                bronk(R_mask | (1 << v), P_mask & adj[v], X_mask & adj[v], size_R + 1)
                P_mask &= ~(1 << v)
                X_mask |= (1 << v)

        # Initial call: R empty, P all vertices, X empty
        all_vertices = (1 << n) - 1
        bronk(0, all_vertices, 0, 0)

        # Return sorted list of indices
        return sorted(best_clique)
<<<SOLVER_PY_END>>>