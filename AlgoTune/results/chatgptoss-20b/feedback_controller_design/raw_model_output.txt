analysisWe need to produce solver.py that implements solve method. We can use cvxpy but maybe faster to use control theory: check stabilizability via rank of [A - λI, B] for eigenvalues outside unit circle? But easier: use controllability matrix and check if (A,B) stabilizable: all uncontrollable modes are stable. Compute controllability matrix C = [B, AB, A^2B, ...]. Rank. Then compute eigenvalues of A. For each eigenvalue λ with |λ|>=1, check if (λI - A) has rank deficiency? Actually stabilizable if all eigenvalues with |λ|>=1 are controllable. Equivalent: For each eigenvalue λ with |λ|>=1, rank([A-λI, B]) == n. We can compute that.

If not stabilizable, return False.

If stabilizable, we need to produce K and P that satisfy Lyapunov inequality. We can compute K via solving discrete-time LQR? But we just need any stabilizing K. We can use pole placement: place poles inside unit circle. Use scipy.signal.place_poles for discrete-time? There's scipy.signal.place_poles for continuous? Actually scipy.signal.place_poles works for continuous-time? It can handle discrete? It has method 'discrete' maybe. Let's check: scipy.signal.place_poles has method 'discrete' parameter? I think it supports discrete. We can use scipy.signal.place_poles(A, B, desired_poles). For discrete, we can specify method='discrete'. Let's use that.

We can choose desired poles as e.g., 0.5 * eigenvalues of A? Or just set all poles to 0.5. For n states, we need n poles. We can set desired_poles = 0.5 * np.ones(n). But if n>1, we need n poles. Use np.full(n, 0.5). That should be inside unit circle. place_poles will compute K.

Then compute P as solution to discrete Lyapunov equation: P = solve_discrete_lyapunov(A_cl, Q) with Q=I. Use scipy.linalg.solve_discrete_lyapunov. That gives P >0.

Return K and P.

Need to ensure K shape m x n. place_poles returns K as shape (m, n). Good.

Edge cases: if B has more columns than needed? place_poles may fail if not enough inputs. But we can try.

If place_poles fails, we can fallback to solving SDP as baseline but slower. But we want fast.

We can also use cvxpy but slower.

Let's implement:

- import numpy as np, scipy.linalg, scipy.signal.

- In solve: parse A,B.

- Check stabilizability: compute eigenvalues of A. For each λ with |λ|>=1, compute rank of [A - λI, B]. Use np.linalg.matrix_rank. If any rank < n, not stabilizable.

- If not stabilizable: return dict.

- Else: compute K via place_poles. Use try: result = scipy.signal.place_poles(A, B, desired_poles, method='discrete'). K = result.gain_matrix. If fails, fallback to cvxpy.

- Compute P: P = scipy.linalg.solve_discrete_lyapunov(A + B @ K, np.eye(n)). Ensure symmetric.

- Return.

We need to ensure K and P are lists of lists.

Also ensure that P is symmetric: we can average P with P.T.

Return dict.

Also need to import typing.Any.

Let's write code accordingly.

Potential issues: place_poles may require that B has full column rank? But we can try.

Also need to handle case m>1: place_poles works.

Let's implement.

Also we need to handle if B is 0? But then not stabilizable.

Ok.

Let's produce solver.py content.

assistantfinal<<<SOLVER_PY_START>>>
from typing import Any
import numpy as np
import scipy.linalg
import scipy.signal

class Solver:
    def solve(self, problem, **kwargs) -> Any:
        """
        Solves the static state feedback controller design problem for a discrete-time LTI system.
        Returns a dictionary with keys:
            - is_stabilizable: bool
            - K: list of lists (m x n) or None
            - P: list of lists (n x n) or None
        """
        # Parse input matrices
        A = np.array(problem["A"], dtype=float)
        B = np.array(problem["B"], dtype=float)
        n, m = A.shape[0], B.shape[1]

        # Helper: check stabilizability
        def is_stabilizable(A, B):
            eigs = np.linalg.eigvals(A)
            for lam in eigs:
                if abs(lam) >= 1.0:
                    # Check rank of [A - lam*I, B]
                    M = np.hstack((A - lam * np.eye(n), B))
                    if np.linalg.matrix_rank(M) < n:
                        return False
            return True

        if not is_stabilizable(A, B):
            return {"is_stabilizable": False, "K": None, "P": None}

        # Attempt to compute a stabilizing K via pole placement
        try:
            # Desired poles: all inside unit circle, e.g., 0.5
            desired_poles = 0.5 * np.ones(n, dtype=complex)
            result = scipy.signal.place_poles(A, B, desired_poles, method="discrete")
            K = result.gain_matrix
        except Exception:
            # Fallback: use a simple LQR with Q=I, R=I to get K
            # Solve discrete-time Riccati equation
            Q = np.eye(n)
            R = np.eye(m)
            # Solve Riccati: X = A^T X A - A^T X B (R + B^T X B)^-1 B^T X A + Q
            # Use scipy.linalg.solve_discrete_are
            X = scipy.linalg.solve_discrete_are(A, B, Q, R)
            K = -np.linalg.inv(R + B.T @ X @ B) @ (B.T @ X @ A)

        # Compute Lyapunov matrix P for closed-loop system
        A_cl = A + B @ K
        try:
            P = scipy.linalg.solve_discrete_lyapunov(A_cl, np.eye(n))
        except Exception:
            # If Lyapunov solver fails, fallback to identity
            P = np.eye(n)

        # Ensure symmetry
        P = (P + P.T) / 2.0

        return {
            "is_stabilizable": True,
            "K": K.tolist(),
            "P": P.tolist()
        }
<<<SOLVER_PY_END>>>