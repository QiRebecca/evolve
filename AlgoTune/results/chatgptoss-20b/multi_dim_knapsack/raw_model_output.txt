analysisWe need to produce solver.py content. We need to implement a solver for Multi-Dimensional Knapsack. Baseline uses OR-Tools CP-SAT. We can try to use OR-Tools as well. But we can also use other libraries like pulp, pyomo, etc. But OR-Tools is efficient. We need to import cp_model from ortools.sat.python. We need to parse problem: MultiDimKnapsackInstance or list/tuple. We need to return list of indices.

We need to implement class Solver with solve method. We can use same baseline code. But we can optimize: maybe use linear programming with pulp? But CP-SAT is fine. We can also use OR-Tools with some heuristics. But baseline uses 24 workers. We can keep that.

We need to import MultiDimKnapsackInstance? It's not defined. The baseline uses type hint. But we can just accept any. We can parse if not instance. But we don't have the class definition. We can just treat problem as tuple/list. The baseline uses MultiDimKnapsackInstance(*problem). We don't have that class. But we can just assume problem is tuple/list of (value, demand, supply). So we can parse accordingly.

Thus implement:

class Solver:
    def solve(self, problem, **kwargs) -> Any:
        if isinstance(problem, (list, tuple)):
            if len(problem) != 3:
                return []
            value, demand, supply = problem
        else:
            # maybe object with attributes
            try:
                value = problem.value
                demand = problem.demand
                supply = problem.supply
            except Exception:
                return []
        n = len(value)
        k = len(supply)
        from ortools.sat.python import cp_model
        model = cp_model.CpModel()
        x = [model.NewBoolVar(f"x_{i}") for i in range(n)]
        for r in range(k):
            model.Add(sum(x[i] * demand[i][r] for i in range(n)) <= supply[r])
        model.Maximize(sum(x[i] * value[i] for i in range(n)))
        solver = cp_model.CpSolver()
        solver.parameters.num_threads = 24
        status = solver.Solve(model)
        if status in (cp_model.OPTIMAL, cp_model.FEASIBLE):
            return [i for i in range(n) if solver.Value(x[i]) == 1]
        return []

We need to import Any. Also we need to import typing.Any. Also we need to import logging? Not necessary. But baseline uses logging. We can skip.

We need to ensure we import cp_model. Use from ortools.sat.python import cp_model.

Also we need to handle potential large n, k. But CP-SAT is fine.

We need to ensure we use solver.parameters.num_threads not num_workers. In CP-SAT, it's num_threads. The baseline uses num_workers. But we can use num_threads.

We need to ensure we return list of indices.

We need to ensure we handle if problem is MultiDimKnapsackInstance. But we don't have that class. But we can just try to access attributes.

Thus final code.

We need to output only the file content between sentinel lines.

Let's produce final.assistantfinal<<<SOLVER_PY_START>>>
from typing import Any

class Solver:
    def solve(self, problem, **kwargs) -> Any:
        """
        Solve a multi-dimensional knapsack problem.

        Parameters
        ----------
        problem : tuple or list or object
            Either a tuple/list of (value, demand, supply) or an object
            with attributes `value`, `demand`, and `supply`.

        Returns
        -------
        list[int]
            List of selected item indices that maximize total value
            while respecting all resource constraints.
        """
        # Parse problem input
        if isinstance(problem, (list, tuple)):
            if len(problem) != 3:
                return []
            value, demand, supply = problem
        else:
            try:
                value = problem.value
                demand = problem.demand
                supply = problem.supply
            except Exception:
                return []

        n = len(value)
        k = len(supply)

        # Build CP-SAT model
        from ortools.sat.python import cp_model

        model = cp_model.CpModel()
        x = [model.NewBoolVar(f"x_{i}") for i in range(n)]

        # Resource constraints
        for r in range(k):
            model.Add(sum(x[i] * demand[i][r] for i in range(n)) <= supply[r])

        # Objective: maximize total value
        model.Maximize(sum(x[i] * value[i] for i in range(n)))

        # Solve
        solver = cp_model.CpSolver()
        solver.parameters.num_threads = 24  # Use up to 24 threads
        status = solver.Solve(model)

        if status in (cp_model.OPTIMAL, cp_model.FEASIBLE):
            return [i for i in range(n) if solver.Value(x[i]) == 1]
        return []
<<<SOLVER_PY_END>>>