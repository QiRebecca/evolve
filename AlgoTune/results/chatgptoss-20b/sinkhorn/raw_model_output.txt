analysisWe need to implement a fast solver for entropic OT. The baseline uses ot.sinkhorn from POT library. We can implement our own Sinkhorn algorithm using numpy for speed. But we can also use POT's sinkhorn if available. But we want faster. We can implement vectorized iterations with log domain to avoid overflow. Use log-domain scaling: K = exp(-M/reg). Then iterative scaling: u = a / (K @ v), v = b / (K.T @ u). Use log-sum-exp for stability. But we can just use standard algorithm with K. For moderate sizes, it's fine.

We need to ensure same output as ot.sinkhorn. The baseline uses ot.sinkhorn which uses log domain? Let's check. POT's sinkhorn uses log domain if reg > 0. It returns G. We need to match. We can implement same algorithm: K = exp(-M/reg). Then u = np.ones(n), v = np.ones(m). Iterate until convergence or max iterations. Use tolerance. But we need to match output exactly. The baseline uses default parameters: max_iter=1000, stopThr=1e-9. We can replicate.

We can implement:

def sinkhorn(a,b,M,reg, max_iter=1000, stop_thr=1e-9):
    K = np.exp(-M/reg)
    u = np.ones_like(a)
    v = np.ones_like(b)
    for i in range(max_iter):
        u_prev = u.copy()
        v_prev = v.copy()
        u = a / (K @ v)
        v = b / (K.T @ u)
        if np.allclose(u, u_prev, rtol=stop_thr) and np.allclose(v, v_prev, rtol=stop_thr):
            break
    G = np.outer(u, v) * K
    return G

But we need to handle division by zero. Use np.where.

Also need to ensure finite values. Use np.clip.

We can also use log domain: u = np.exp(log_u), etc. But simpler.

We need to import numpy as np.

We need to handle potential overflow in exp(-M/reg). If M/reg large, exp(-large) -> 0. That's fine.

We need to ensure shape.

We need to return dict with "transport_plan": G, "error_message": None. If error, return None and error_message.

We need to catch exceptions.

We need to import logging? Not necessary.

We need to use typing.Any.

Implement class Solver with solve method.

We need to ensure that the output matches ot.sinkhorn within tolerance. Our algorithm may produce slightly different due to iteration tolerance. We can set max_iter=1000, stop_thr=1e-9. That should match.

But we need to ensure that we use same scaling as POT. Let's check POT's sinkhorn implementation. It uses K = np.exp(-M / reg). Then u = a / (K @ v). v = b / (K.T @ u). It uses log domain if reg > 0? Actually POT's sinkhorn uses log domain if reg > 0? Let's quickly recall: In POT, sinkhorn uses log domain if reg > 0? I think it uses log domain if reg > 0? Wait, the function ot.sinkhorn uses the standard algorithm. It has parameters: reg, numItermax, stopThr, verbose, log, etc. It uses K = np.exp(-M / reg). Then u = np.ones(n), v = np.ones(m). Then for i in range(numItermax): u = a / (K @ v); v = b / (K.T @ u). Then G = np.outer(u, v) * K. So our implementation matches.

Thus we can implement same.

We need to ensure that we use np.asarray for a,b,M.

Also need to handle potential division by zero: if K @ v has zeros, we can add small epsilon.

We can use np.where(K @ v == 0, 1e-16, K @ v).

Similarly for K.T @ u.

Also we can use np.clip to avoid overflow.

Let's implement.

Also we need to import typing.Any.

We need to ensure that the function returns dict with "transport_plan": G, "error_message": None.

If error, return {"transport_plan": None, "error_message": str(exc)}.

We need to ensure that G is numpy array.

We need to ensure that G is finite.

We can check np.isfinite(G).all().

If not, raise ValueError.

We need to catch exceptions.

We need to import numpy as np.

We need to import typing.Any.

We need to implement class Solver.

Let's write code.

We need to ensure that we don't import ot. So we implement our own.

We need to ensure that we use np.exp(-M / reg). If reg is zero? But reg > 0.

We need to handle large M/reg causing overflow in exp. But exp(-large) -> 0, fine.

We need to ensure that we use np.maximum to avoid division by zero.

We can set eps = 1e-16.

Implementation:

def _sinkhorn(a,b,M,reg,max_iter=1000,stop_thr=1e-9):
    K = np.exp(-M / reg)
    u = np.ones_like(a)
    v = np.ones_like(b)
    for _ in range(max_iter):
        u_prev = u.copy()
        v_prev = v.copy()
        K_v = K @ v
        K_v = np.where(K_v == 0, 1e-16, K_v)
        u = a / K_v
        K_T_u = K.T @ u
        K_T_u = np.where(K_T_u == 0, 1e-16, K_T_u)
        v = b / K_T_u
        if np.allclose(u, u_prev, rtol=stop_thr) and np.allclose(v, v_prev, rtol=stop_thr):
            break
    G = np.outer(u, v) * K
    return G

We need to ensure that we use np.asarray for a,b,M.

We need to ensure that we use dtype float64.

We need to ensure that we use np.ascontiguousarray for M.

We need to ensure that we use np.array for a,b.

We need to ensure that we use np.float64.

We need to ensure that we use np.isfinite(G).all().

We need to ensure that we return dict.

Ok.

Let's write final code.

We need to wrap entire file between sentinel lines.

Let's produce final answer.assistantfinal<<<SOLVER_PY_START>>>
from typing import Any
import numpy as np

class Solver:
    def solve(self, problem, **kwargs) -> Any:
        """
        Compute the entropically regularized optimal transport plan using the Sinkhorn algorithm.
        """
        try:
            a = np.asarray(problem["source_weights"], dtype=np.float64)
            b = np.asarray(problem["target_weights"], dtype=np.float64)
            M = np.ascontiguousarray(problem["cost_matrix"], dtype=np.float64)
            reg = float(problem["reg"])

            # Parameters matching POT's default
            max_iter = 1000
            stop_thr = 1e-9
            eps = 1e-16

            # Compute kernel matrix
            K = np.exp(-M / reg)

            # Initialize scaling vectors
            u = np.ones_like(a)
            v = np.ones_like(b)

            for _ in range(max_iter):
                u_prev = u.copy()
                v_prev = v.copy()

                K_v = K @ v
                K_v = np.where(K_v == 0, eps, K_v)
                u = a / K_v

                K_T_u = K.T @ u
                K_T_u = np.where(K_T_u == 0, eps, K_T_u)
                v = b / K_T_u

                if np.allclose(u, u_prev, rtol=stop_thr) and np.allclose(v, v_prev, rtol=stop_thr):
                    break

            G = np.outer(u, v) * K

            if not np.isfinite(G).all():
                raise ValueError("Nonâ€‘finite values in transport plan")

            return {"transport_plan": G, "error_message": None}
        except Exception as exc:
            return {"transport_plan": None, "error_message": str(exc)}
<<<SOLVER_PY_END>>>