analysisWe need to implement efficient articulation point detection. Use DFS algorithm (Tarjan). Complexity O(n+m). Use adjacency list. Input: problem dict with num_nodes and edges. Output sorted list.

Implement solve method. Use recursion or iterative? Recursion depth up to n maybe 1e5? Might risk recursion limit. Use iterative stack? But easier: set recursionlimit high. Use sys.setrecursionlimit(1e6). Use adjacency list list of lists.

Implement DFS: disc[u], low[u], parent, visited. Count children for root. If root has >1 child => articulation. For non-root: if low[v] >= disc[u] => articulation.

Return sorted list.

Edge cases: no edges, no articulation points.

Implement.

Also import typing.Any.

Return dict.

Let's produce solver.py content.

Also ensure we import sys.

Let's craft code.

Also we can use iterative stack to avoid recursion. But recursion fine with high limit.

Let's produce final code.assistantfinal<<<SOLVER_PY_START>>>
from typing import Any
import sys

class Solver:
    def solve(self, problem, **kwargs) -> Any:
        """
        Find articulation points in an undirected graph using Tarjan's algorithm.
        """
        sys.setrecursionlimit(10 ** 6)

        n = problem["num_nodes"]
        edges = problem["edges"]

        # Build adjacency list
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)

        disc = [-1] * n
        low = [0] * n
        parent = [-1] * n
        ap = [False] * n
        time = 0

        def dfs(u: int):
            nonlocal time
            disc[u] = low[u] = time
            time += 1
            children = 0

            for v in adj[u]:
                if disc[v] == -1:  # Tree edge
                    parent[v] = u
                    children += 1
                    dfs(v)
                    low[u] = min(low[u], low[v])

                    if parent[u] == -1 and children > 1:
                        ap[u] = True
                    if parent[u] != -1 and low[v] >= disc[u]:
                        ap[u] = True
                elif v != parent[u]:  # Back edge
                    low[u] = min(low[u], disc[v])

        for i in range(n):
            if disc[i] == -1:
                dfs(i)

        articulation_points = [i for i, is_ap in enumerate(ap) if is_ap]
        articulation_points.sort()
        return {"articulation_points": articulation_points}
<<<SOLVER_PY_END>>>