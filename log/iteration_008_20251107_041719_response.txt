The current solver is already faster than baseline by leveraging the low-level `Cipher` API, but it still rebuilds costly internal objects for every call.  
Iâ€™ll add lightweight caching of the AES key schedule and use `update_into` to eliminate an extra memory allocation, squeezing out additional performance.

```python
import hmac
import logging
import os
from typing import Any, Final, Dict

from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes

# --------------------------------------------------------------------------- #
# Constants (module-level look-ups are fastest)
# --------------------------------------------------------------------------- #
_AES_KEY_SIZES: Final = (16, 24, 32)   # Valid AES sizes: 128/192/256-bit
_GCM_NONCE_SIZE: Final = 12            # Recommended nonce length for GCM
_GCM_TAG_SIZE: Final = 16              # Authentication tag length (bytes)


class Solver:
    """
    AES-GCM encryption solver.

    Input  : {"key", "nonce", "plaintext", "associated_data"}
    Output : {"ciphertext", "tag"}
    """

    __slots__ = ("_algo_cache",)

    # Helper constants for the (optional) generator
    _DEFAULT_KEY_SIZE: Final = 16       # AES-128
    _DEFAULT_PTXT_MULT: Final = 1024    # bytes per unit n

    def __init__(self) -> None:
        # Cache AES key schedules to avoid re-computing round keys
        self._algo_cache: Dict[bytes, algorithms.AES] = {}

    # --------------------------------------------------------------------- #
    # Core solve function (entry point for the evaluator)
    # --------------------------------------------------------------------- #
    def solve(self, problem: dict[str, Any], **__) -> dict[str, bytes]:
        """
        Encrypt *plaintext* under AES-GCM with provided parameters.
        """
        key: bytes        = problem["key"]
        nonce: bytes      = problem["nonce"]
        plaintext: bytes  = problem["plaintext"]
        aad: bytes | None = problem["associated_data"]

        # Quick key-size sanity check (let backend handle detailed validation)
        if len(key) not in _AES_KEY_SIZES:
            raise ValueError(f"Unsupported AES key length {len(key)} bytes.")

        # Fetch or create cached AES algorithm object (contains key schedule)
        algo = self._algo_cache.get(key)
        if algo is None:
            algo = algorithms.AES(key)
            self._algo_cache[key] = algo

        # Create encryptor for current nonce
        encryptor = Cipher(algo, modes.GCM(nonce)).encryptor()

        # Attach AAD if any (bytes() truthiness covers None/empty)
        if aad:
            encryptor.authenticate_additional_data(aad)

        # Encrypt in a single pass WITHOUT extra allocations
        out = bytearray(len(plaintext))
        written = encryptor.update_into(plaintext, out)
        if written != len(plaintext):
            # update_into must consume full plaintext
            raise ValueError("Incomplete encryption output.")
        encryptor.finalize()

        # Extract tag directly (no slicing needed)
        tag: bytes = encryptor.tag
        ciphertext: bytes = bytes(out)  # convert to immutable bytes

        return {"ciphertext": ciphertext, "tag": tag}

    # --------------------------------------------------------------------- #
    # Reference checker (matches task specification)
    # --------------------------------------------------------------------- #
    def is_solution(self, problem: dict[str, Any], solution: dict[str, bytes] | Any) -> bool:
        """
        Constant-time verification of *solution* against reference result.
        """
        if (
            not isinstance(solution, dict)
            or "ciphertext" not in solution
            or "tag" not in solution
            or not isinstance(solution["ciphertext"], (bytes, bytearray))
            or not isinstance(solution["tag"], (bytes, bytearray))
        ):
            logging.error("Invalid solution format.")
            return False

        reference = self.solve(problem)
        return (
            hmac.compare_digest(reference["ciphertext"], solution["ciphertext"])
            and hmac.compare_digest(reference["tag"], solution["tag"])
        )

    # --------------------------------------------------------------------- #
    # Optional: example problem generator (not used by evaluator)
    # --------------------------------------------------------------------- #
    def generate_problem(self, n: int, random_seed: int = 1) -> dict[str, Any]:
        """
        Produce a random AES-GCM encryption instance scaled by *n*.
        """
        key       = os.urandom(self._DEFAULT_KEY_SIZE)
        nonce     = os.urandom(_GCM_NONCE_SIZE)
        plaintext = os.urandom(max(1, n * self._DEFAULT_PTXT_MULT))
        aad       = os.urandom(32) if n & 1 == 0 else b""

        return {
            "key": key,
            "nonce": nonce,
            "plaintext": plaintext,
            "associated_data": aad,
        }
```