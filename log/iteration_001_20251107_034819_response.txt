The primary bottleneck is the extra memory-copy step incurred by `AESGCM.encrypt`, which appends the tag to the ciphertext and then requires an additional slice to separate them.  
By switching to the lower-level `Cipher` + `GCM` interface we can obtain the ciphertext and tag in one pass, eliminating that redundant copy. This reduces both memory traffic and runtime, especially for large plaintexts, while preserving identical results.

```python
import hmac
import logging
import os
from typing import Any, Final

from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

# Constants (module-level for quick access)
AES_KEY_SIZES: Final = (16, 24, 32)           # AES-128, 192, 256
GCM_NONCE_SIZE: Final = 12                    # Recommended nonce length for GCM
GCM_TAG_SIZE:  Final = 16                     # Authentication tag size


class Solver:
    """
    AES-GCM encryption task solver.

    For every invocation `solve` receives a dictionary with:
        key, nonce, plaintext, associated_data

    It returns a dictionary with:
        ciphertext – encrypted bytes
        tag        – 16-byte authentication tag
    """

    # Problem generation helpers (kept for completeness; not used by judge)
    DEFAULT_KEY_SIZE: Final = 16              # AES-128
    DEFAULT_PLAINTEXT_MULT: Final = 1024      # bytes per n-unit

    # --------------------------------------------------------------------- #
    # Public API used by the evaluation harness
    # --------------------------------------------------------------------- #
    def solve(self, problem: dict[str, Any], **_) -> dict[str, bytes]:
        """
        Encrypt *plaintext* with AES-GCM under *key*/*nonce*.

        Args
        ----
        problem : dict
            {
              "key": bytes,
              "nonce": bytes,
              "plaintext": bytes,
              "associated_data": bytes | None
            }

        Returns
        -------
        dict
            {"ciphertext": bytes, "tag": bytes}
        """
        # Micro-optimise local look-ups
        key          = problem["key"]
        nonce        = problem["nonce"]
        plaintext    = problem["plaintext"]
        associated   = problem["associated_data"]

        # Fast key-size sanity check (lets cryptography perform full validation)
        if len(key) not in AES_KEY_SIZES:
            raise ValueError(
                f"Invalid AES key length {len(key)}; expected one of {AES_KEY_SIZES}"
            )

        # Build encryptor (leverages OpenSSL’s highly-tuned implementation)
        encryptor = Cipher(
            algorithms.AES(key),
            modes.GCM(nonce),
            backend=default_backend(),  # cached singleton
        ).encryptor()

        # Supply AAD only if present
        if associated:
            encryptor.authenticate_additional_data(associated)

        # Single-pass encryption; no redundant copies
        ciphertext = encryptor.update(plaintext) + encryptor.finalize()
        tag = encryptor.tag  # 16-byte authentication tag

        return {"ciphertext": ciphertext, "tag": tag}

    # --------------------------------------------------------------------- #
    # Reference checker – identical semantics to original implementation
    # --------------------------------------------------------------------- #
    def is_solution(self, problem: dict[str, Any], solution: dict[str, bytes] | Any) -> bool:
        """
        Validate *solution* by comparing with this solver’s output using
        constant-time equality checks.
        """
        if (
            not isinstance(solution, dict)
            or "ciphertext" not in solution
            or "tag" not in solution
            or not isinstance(solution["ciphertext"], (bytes, bytearray))
            or not isinstance(solution["tag"], (bytes, bytearray))
        ):
            logging.error("Solution format invalid.")
            return False

        ref = self.solve(problem)
        return (
            hmac.compare_digest(ref["ciphertext"], solution["ciphertext"])
            and hmac.compare_digest(ref["tag"], solution["tag"])
        )

    # --------------------------------------------------------------------- #
    # Optional: utility to produce fresh problems (not required by harness)
    # --------------------------------------------------------------------- #
    def generate_problem(self, n: int, random_seed: int = 1) -> dict[str, Any]:
        """
        Create a random AES-GCM encryption instance sized by *n*.
        """
        # Cryptographically secure randomness; seed ignored for security
        key       = os.urandom(self.DEFAULT_KEY_SIZE)
        nonce     = os.urandom(GCM_NONCE_SIZE)
        plaintext = os.urandom(max(1, n * self.DEFAULT_PLAINTEXT_MULT))
        aad       = os.urandom(32) if n % 2 == 0 else b""

        return {
            "key": key,
            "nonce": nonce,
            "plaintext": plaintext,
            "associated_data": aad,
        }
```