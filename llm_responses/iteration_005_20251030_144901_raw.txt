The baseline performs extensive logging and validation that add overhead, and it rebuilds the AESGCM object every call.  
I'll remove unnecessary checks/logging and add a tiny cache so a `AESGCM` instance is reused when the same key occurs, eliminating object-creation cost.

```python
from typing import Any, Dict

from cryptography.hazmat.primitives.ciphers.aead import AESGCM


class Solver:
    """
    Fast AES-GCM encryption solver.

    The output format matches the baseline:
        {
            "ciphertext": <bytes without tag>,
            "tag": <16-byte authentication tag>
        }
    """

    # Small class-wide cache: key-bytes -> AESGCM instance
    _aesgcm_cache: Dict[bytes, AESGCM] = {}

    # Constant for tag length in bytes (GCM uses 128-bit tags by default)
    _TAG_LEN = 16

    def solve(self, problem: dict[str, Any], **kwargs) -> dict[str, bytes]:
        """
        Encrypt the provided plaintext with AES-GCM.

        Parameters
        ----------
        problem : dict
            Dictionary containing:
              • key : bytes
              • nonce : bytes
              • plaintext : bytes
              • associated_data : bytes | None

        Returns
        -------
        dict
            { "ciphertext": bytes, "tag": bytes }
        """
        key: bytes = problem["key"]
        nonce: bytes = problem["nonce"]
        plaintext: bytes = problem["plaintext"]
        aad: bytes | None = problem.get("associated_data", None)

        # Re-use AESGCM instance when possible (instantiation is non-trivial)
        aesgcm = self._aesgcm_cache.get(key)
        if aesgcm is None:
            aesgcm = AESGCM(key)
            self._aesgcm_cache[key] = aesgcm

        encrypted: bytes = aesgcm.encrypt(nonce, plaintext, aad)

        # Split off authentication tag (last 16 bytes)
        tag = encrypted[-self._TAG_LEN :]
        ciphertext = encrypted[:-self._TAG_LEN]

        return {"ciphertext": ciphertext, "tag": tag}
```