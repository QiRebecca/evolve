The original implementation included extensive logging, validation, and task-registration boilerplate that aren’t required by the evaluator.  
I’ll deliver a compact `Solver` class that performs the same AES-GCM encryption while eliminating all non-essential overhead.

```python
from typing import Any
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

# Standard GCM authentication-tag length (bytes)
_GCM_TAG_LEN = 16


class Solver:
    def solve(self, problem: dict[str, Any], **kwargs) -> dict[str, bytes]:
        """
        Encrypt `problem["plaintext"]` with AES-GCM and return the ciphertext
        (without the authentication tag) and the tag itself.

        The function expects `problem` to contain:
            - key: bytes (length 16, 24 or 32)
            - nonce: bytes (typically 12 bytes for GCM)
            - plaintext: bytes
            - associated_data: bytes | None
        """
        key: bytes = problem["key"]
        nonce: bytes = problem["nonce"]
        plaintext: bytes = problem["plaintext"]
        aad: bytes | None = problem.get("associated_data", None)

        # Perform encryption
        full_ct: bytes = AESGCM(key).encrypt(nonce, plaintext, aad)

        # Split ciphertext and tag (last 16 bytes)
        return {
            "ciphertext": full_ct[:-_GCM_TAG_LEN],
            "tag": full_ct[-_GCM_TAG_LEN:],
        }
```
