The current version already caches AESGCM objects but does the LRU bookkeeping in pure-Python.  
Replacing that with `functools.lru_cache`, whose bookkeeping is implemented in C, removes Python-level overhead and slightly trims the critical path.

```python
from functools import lru_cache
from typing import Any, Dict

from cryptography.hazmat.primitives.ciphers.aead import AESGCM

# Valid AES key lengths (bytes) and fixed GCM tag length
_VALID_KEY_SIZES = {16, 24, 32}
_TAG_LEN = 16


@lru_cache(maxsize=64)
def _cipher_for_key(key: bytes) -> AESGCM:
    """
    Return (and cache) an AESGCM object for the supplied key.
    The lru_cache decorator gives us an efficient, C-level LRU without
    writing our own bookkeeping code.
    """
    if len(key) not in _VALID_KEY_SIZES:
        raise ValueError("AES key must be 16, 24 or 32 bytes long.")
    return AESGCM(key)


class Solver:
    """
    Minimal, fast AES-GCM encryption solver.
    """

    __slots__ = ()  # avoid per-instance __dict__

    def solve(self, problem: Dict[str, Any], **_) -> Dict[str, bytes]:
        """
        Encrypt `problem["plaintext"]` with AES-GCM and return separate
        ciphertext and authentication tag.

        Expected `problem` keys:
            key: bytes
            nonce: bytes
            plaintext: bytes
            associated_data: bytes | None
        """
        key = problem["key"]
        aes = _cipher_for_key(key)

        ct_tag = aes.encrypt(
            problem["nonce"],
            problem["plaintext"],
            problem.get("associated_data"),
        )

        # AESGCM appends a 16-byte tag to the ciphertext
        return {"ciphertext": ct_tag[:-_TAG_LEN], "tag": ct_tag[-_TAG_LEN:]}
```