The original code bundled task-generation logic and extensive logging, adding overhead while the heavy-lifting step is the AES-GCM encryption itself.  
I’ll streamline the implementation to only what the evaluator requires (a `Solver` class with a `solve` method), drop superfluous checks/logging, and cache `AESGCM` objects per-key to avoid re-initialisation overhead when the same key is reused. This shrinks code size and trims constant-factor runtime.

```python
from typing import Any, Dict
import hmac

from cryptography.hazmat.primitives.ciphers.aead import AESGCM

# Valid AES key lengths (bytes) and fixed GCM tag size
_AES_KEY_SIZES = {16, 24, 32}
_GCM_TAG_SIZE = 16


class Solver:
    """
    Fast AES-GCM encryptor that matches the baseline’s behaviour while reducing
    overhead.  An internal LRU-style cache avoids repeatedly constructing
    AESGCM objects when identical keys are used across calls.
    """

    # Simple unbounded cache; in typical benchmarks the number of distinct
    # keys is limited, and this avoids per-call instantiation cost.
    _aes_cache: Dict[bytes, AESGCM] = {}

    @staticmethod
    def _get_aes(key: bytes) -> AESGCM:
        try:
            return Solver._aes_cache[key]
        except KeyError:
            aes = AESGCM(key)
            Solver._aes_cache[key] = aes
            return aes

    def solve(self, problem: Dict[str, Any], **kwargs) -> Dict[str, bytes]:
        """
        Encrypt `problem["plaintext"]` with AES-GCM, returning separate
        ciphertext and authentication tag to mirror the baseline output.
        """
        key: bytes = problem["key"]
        nonce: bytes = problem["nonce"]
        plaintext: bytes = problem["plaintext"]
        aad: bytes | None = problem.get("associated_data")

        if len(key) not in _AES_KEY_SIZES:
            raise ValueError("Unsupported AES key length.")

        aesgcm = self._get_aes(key)

        # cryptography returns ciphertext || tag
        combined = aesgcm.encrypt(nonce, plaintext, aad)
        if len(combined) < _GCM_TAG_SIZE:
            raise ValueError("Ciphertext shorter than tag size.")

        return {
            "ciphertext": combined[:-_GCM_TAG_SIZE],
            "tag": combined[-_GCM_TAG_SIZE:],
        }
```